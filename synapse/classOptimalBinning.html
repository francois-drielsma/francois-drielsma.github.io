<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>SynAPSE: OptimalBinning Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">SynAPSE
   &#160;<span id="projectnumber">0.6.0</span>
   </div>
   <div id="projectbrief">Synergistic Analysis of Phase Space Evolution</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">OptimalBinning Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Computes the Optimal Binning density estimator of a set of points.  
 <a href="classOptimalBinning.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="OptimalBinning_8hh_source.html">OptimalBinning.hh</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a335ad72374786d2b96bd8cbd064d4323"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimalBinning.html#a335ad72374786d2b96bd8cbd064d4323">OptimalBinning</a> ()</td></tr>
<tr class="memdesc:a335ad72374786d2b96bd8cbd064d4323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor, initilizes everything to 0.  <a href="#a335ad72374786d2b96bd8cbd064d4323">More...</a><br/></td></tr>
<tr class="separator:a335ad72374786d2b96bd8cbd064d4323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91df804b949ec87dae990e4ff442872a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimalBinning.html#a91df804b949ec87dae990e4ff442872a">OptimalBinning</a> (const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;points, const std::string algo=&quot;scott&quot;, const bool interp=true, const bool ex=true)</td></tr>
<tr class="memdesc:a91df804b949ec87dae990e4ff442872a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cloud constructor, sets vector of points and their mapping for a point cloud.  <a href="#a91df804b949ec87dae990e4ff442872a">More...</a><br/></td></tr>
<tr class="separator:a91df804b949ec87dae990e4ff442872a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416eda2ca870427f91cfd56752e71f72"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimalBinning.html#a416eda2ca870427f91cfd56752e71f72">OptimalBinning</a> (const <a class="el" href="classOptimalBinning.html">OptimalBinning</a> &amp;ob)</td></tr>
<tr class="memdesc:a416eda2ca870427f91cfd56752e71f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a416eda2ca870427f91cfd56752e71f72">More...</a><br/></td></tr>
<tr class="separator:a416eda2ca870427f91cfd56752e71f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f1b07d9c98fcfab99888e88b8e3cd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOptimalBinning.html">OptimalBinning</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimalBinning.html#a09f1b07d9c98fcfab99888e88b8e3cd7">operator=</a> (const <a class="el" href="classOptimalBinning.html">OptimalBinning</a> &amp;ob)</td></tr>
<tr class="memdesc:a09f1b07d9c98fcfab99888e88b8e3cd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator.  <a href="#a09f1b07d9c98fcfab99888e88b8e3cd7">More...</a><br/></td></tr>
<tr class="separator:a09f1b07d9c98fcfab99888e88b8e3cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b77dd36ac6fff9f31a6dd314e1e7a12"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimalBinning.html#a2b77dd36ac6fff9f31a6dd314e1e7a12">operator()</a> (const std::vector&lt; double &gt; &amp;v) const </td></tr>
<tr class="memdesc:a2b77dd36ac6fff9f31a6dd314e1e7a12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded function operator, calls Evaluate.  <a href="#a2b77dd36ac6fff9f31a6dd314e1e7a12">More...</a><br/></td></tr>
<tr class="separator:a2b77dd36ac6fff9f31a6dd314e1e7a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed29b458a64a6f9897b357b4f125bcd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimalBinning.html#a9ed29b458a64a6f9897b357b4f125bcd">operator()</a> (const double &amp;v) const </td></tr>
<tr class="memdesc:a9ed29b458a64a6f9897b357b4f125bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded function operator, calls Evaluate.  <a href="#a9ed29b458a64a6f9897b357b4f125bcd">More...</a><br/></td></tr>
<tr class="separator:a9ed29b458a64a6f9897b357b4f125bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab71e6a54281a0be74b2c3ce641a4137"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimalBinning.html#aab71e6a54281a0be74b2c3ce641a4137">operator()</a> (const double *v) const </td></tr>
<tr class="memdesc:aab71e6a54281a0be74b2c3ce641a4137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded function operator, calls Evaluate.  <a href="#aab71e6a54281a0be74b2c3ce641a4137">More...</a><br/></td></tr>
<tr class="separator:aab71e6a54281a0be74b2c3ce641a4137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6028ffb4fa64f8dd458d4816a24305"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimalBinning.html#a0a6028ffb4fa64f8dd458d4816a24305">~OptimalBinning</a> ()</td></tr>
<tr class="memdesc:a0a6028ffb4fa64f8dd458d4816a24305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a0a6028ffb4fa64f8dd458d4816a24305">More...</a><br/></td></tr>
<tr class="separator:a0a6028ffb4fa64f8dd458d4816a24305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1683035d05edcc99ecf90344129b7c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimalBinning.html#ae1683035d05edcc99ecf90344129b7c6">Initialize</a> (const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;points, const std::string &amp;algo)</td></tr>
<tr class="memdesc:ae1683035d05edcc99ecf90344129b7c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the histogram with the optimal binning.  <a href="#ae1683035d05edcc99ecf90344129b7c6">More...</a><br/></td></tr>
<tr class="separator:ae1683035d05edcc99ecf90344129b7c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de5cd858b0d5b8eb5ea76c916ec2b30"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimalBinning.html#a0de5cd858b0d5b8eb5ea76c916ec2b30">Evaluate</a> (const std::vector&lt; double &gt; &amp;v) const </td></tr>
<tr class="memdesc:a0de5cd858b0d5b8eb5ea76c916ec2b30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the density estimation at an n-point v.  <a href="#a0de5cd858b0d5b8eb5ea76c916ec2b30">More...</a><br/></td></tr>
<tr class="separator:a0de5cd858b0d5b8eb5ea76c916ec2b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c9d3224b5f643c95964c8e68ec4e1b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimalBinning.html#a43c9d3224b5f643c95964c8e68ec4e1b">Evaluate</a> (const double &amp;v) const </td></tr>
<tr class="memdesc:a43c9d3224b5f643c95964c8e68ec4e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the density estimation at an n-point v.  <a href="#a43c9d3224b5f643c95964c8e68ec4e1b">More...</a><br/></td></tr>
<tr class="separator:a43c9d3224b5f643c95964c8e68ec4e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af886dab1333c68703afb03a0a5f80b9f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimalBinning.html#af886dab1333c68703afb03a0a5f80b9f">Evaluate</a> (const double *v) const </td></tr>
<tr class="memdesc:af886dab1333c68703afb03a0a5f80b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the density estimation at an n-point v.  <a href="#af886dab1333c68703afb03a0a5f80b9f">More...</a><br/></td></tr>
<tr class="separator:af886dab1333c68703afb03a0a5f80b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05374f59f2ecaf15afbae3d72331c318"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimalBinning.html#a05374f59f2ecaf15afbae3d72331c318">GetLowerBoundArray</a> () const </td></tr>
<tr class="memdesc:a05374f59f2ecaf15afbae3d72331c318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the array of lower bounds in each dimension.  <a href="#a05374f59f2ecaf15afbae3d72331c318">More...</a><br/></td></tr>
<tr class="separator:a05374f59f2ecaf15afbae3d72331c318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509b573291a0c82bc69f6e07c14b9930"><td class="memItemLeft" align="right" valign="top">const double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimalBinning.html#a509b573291a0c82bc69f6e07c14b9930">GetLowerBound</a> (const size_t i=0) const </td></tr>
<tr class="memdesc:a509b573291a0c82bc69f6e07c14b9930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lower bound in dimension i.  <a href="#a509b573291a0c82bc69f6e07c14b9930">More...</a><br/></td></tr>
<tr class="separator:a509b573291a0c82bc69f6e07c14b9930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a876b1ad91dc43ff86a76547b456d9d03"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimalBinning.html#a876b1ad91dc43ff86a76547b456d9d03">GetUpperBoundArray</a> () const </td></tr>
<tr class="memdesc:a876b1ad91dc43ff86a76547b456d9d03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the array of upper bounds in each dimension.  <a href="#a876b1ad91dc43ff86a76547b456d9d03">More...</a><br/></td></tr>
<tr class="separator:a876b1ad91dc43ff86a76547b456d9d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4689003ee0d095cf1774cf047bea707e"><td class="memItemLeft" align="right" valign="top">const double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimalBinning.html#a4689003ee0d095cf1774cf047bea707e">GetUpperBound</a> (const size_t i=0) const </td></tr>
<tr class="memdesc:a4689003ee0d095cf1774cf047bea707e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the upper bound in dimension i.  <a href="#a4689003ee0d095cf1774cf047bea707e">More...</a><br/></td></tr>
<tr class="separator:a4689003ee0d095cf1774cf047bea707e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7914894bf31703359b756561dbcc67"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimalBinning.html#acd7914894bf31703359b756561dbcc67">GetNbins</a> (const size_t i=0) const </td></tr>
<tr class="memdesc:acd7914894bf31703359b756561dbcc67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the amount of bins in one projection.  <a href="#acd7914894bf31703359b756561dbcc67">More...</a><br/></td></tr>
<tr class="separator:acd7914894bf31703359b756561dbcc67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444434f52f1b4579c5c11a94504151cb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; TPolyLine * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimalBinning.html#a444434f52f1b4579c5c11a94504151cb">Meshing</a> () const </td></tr>
<tr class="memdesc:a444434f52f1b4579c5c11a94504151cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the meshing, used to build the interpolation, as polygons.  <a href="#a444434f52f1b4579c5c11a94504151cb">More...</a><br/></td></tr>
<tr class="separator:a444434f52f1b4579c5c11a94504151cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a96b27003537da10a26f1a3205251b4b3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimalBinning.html#a96b27003537da10a26f1a3205251b4b3">_dim</a></td></tr>
<tr class="memdesc:a96b27003537da10a26f1a3205251b4b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dimension of the space the estimator lives in.  <a href="#a96b27003537da10a26f1a3205251b4b3">More...</a><br/></td></tr>
<tr class="separator:a96b27003537da10a26f1a3205251b4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc27a1e5fb9764cfc0596640b1827dc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHistogram.html">Histogram</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimalBinning.html#adc27a1e5fb9764cfc0596640b1827dc9">_hist</a></td></tr>
<tr class="memdesc:adc27a1e5fb9764cfc0596640b1827dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimal histogram for density estimation.  <a href="#adc27a1e5fb9764cfc0596640b1827dc9">More...</a><br/></td></tr>
<tr class="separator:adc27a1e5fb9764cfc0596640b1827dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f7e8874e0939fbcc2bd8310de515c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classInterpolator.html">Interpolator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimalBinning.html#a19f7e8874e0939fbcc2bd8310de515c7">_int</a></td></tr>
<tr class="memdesc:a19f7e8874e0939fbcc2bd8310de515c7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classGrid.html" title="Data structure for a grid of points and their mapping onto a scalar field. ">Grid</a> interpolator.  <a href="#a19f7e8874e0939fbcc2bd8310de515c7">More...</a><br/></td></tr>
<tr class="separator:a19f7e8874e0939fbcc2bd8310de515c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84bae9eeb8c8ce34b3390ae5bec1e94b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimalBinning.html#a84bae9eeb8c8ce34b3390ae5bec1e94b">_interp</a></td></tr>
<tr class="memdesc:a84bae9eeb8c8ce34b3390ae5bec1e94b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply grid interpolation if true.  <a href="#a84bae9eeb8c8ce34b3390ae5bec1e94b">More...</a><br/></td></tr>
<tr class="separator:a84bae9eeb8c8ce34b3390ae5bec1e94b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab7873e2cb07e512a012df313924f23"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOptimalBinning.html#a0ab7873e2cb07e512a012df313924f23">_ex</a></td></tr>
<tr class="memdesc:a0ab7873e2cb07e512a012df313924f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extrapolate if true.  <a href="#a0ab7873e2cb07e512a012df313924f23">More...</a><br/></td></tr>
<tr class="separator:a0ab7873e2cb07e512a012df313924f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Computes the Optimal Binning density estimator of a set of points. </p>
<p>This method finds the optimal binning of the space by an array of different methods. The amount of data points in each bin is directly related to the density in the bin. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a335ad72374786d2b96bd8cbd064d4323"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OptimalBinning::OptimalBinning </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor, initilizes everything to 0. </p>

</div>
</div>
<a class="anchor" id="a91df804b949ec87dae990e4ff442872a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OptimalBinning::OptimalBinning </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>algo</em> = <code>&quot;scott&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>interp</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ex</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cloud constructor, sets vector of points and their mapping for a point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>N points in a _dim dimensional space </td></tr>
    <tr><td class="paramname">algo</td><td>Algorithm to be used for binning optimization </td></tr>
    <tr><td class="paramname">interp</td><td>Perform an interpolation on the histogram if requested </td></tr>
    <tr><td class="paramname">ex</td><td>Extrapolate outside the outmost points if requested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a416eda2ca870427f91cfd56752e71f72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OptimalBinning::OptimalBinning </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOptimalBinning.html">OptimalBinning</a> &amp;&#160;</td>
          <td class="paramname"><em>ob</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>

</div>
</div>
<a class="anchor" id="a0a6028ffb4fa64f8dd458d4816a24305"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OptimalBinning::~OptimalBinning </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a0de5cd858b0d5b8eb5ea76c916ec2b30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OptimalBinning::Evaluate </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the density estimation at an n-point v. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td><a class="el" href="classVector.html" title="Object that can host any type of data in a vector arrangement. ">Vector</a> of coordinates of the n-point </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a43c9d3224b5f643c95964c8e68ec4e1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OptimalBinning::Evaluate </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the density estimation at an n-point v. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>One dimensional value of the point </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af886dab1333c68703afb03a0a5f80b9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OptimalBinning::Evaluate </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the density estimation at an n-point v. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Pointer to an array of coordinates of the n-point </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a509b573291a0c82bc69f6e07c14b9930"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double&amp; OptimalBinning::GetLowerBound </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>i</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the lower bound in dimension i. </p>

</div>
</div>
<a class="anchor" id="a05374f59f2ecaf15afbae3d72331c318"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;double&gt;&amp; OptimalBinning::GetLowerBoundArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the array of lower bounds in each dimension. </p>

</div>
</div>
<a class="anchor" id="acd7914894bf31703359b756561dbcc67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t OptimalBinning::GetNbins </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>i</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the amount of bins in one projection. </p>

</div>
</div>
<a class="anchor" id="a4689003ee0d095cf1774cf047bea707e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double&amp; OptimalBinning::GetUpperBound </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>i</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the upper bound in dimension i. </p>

</div>
</div>
<a class="anchor" id="a876b1ad91dc43ff86a76547b456d9d03"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;double&gt;&amp; OptimalBinning::GetUpperBoundArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the array of upper bounds in each dimension. </p>

</div>
</div>
<a class="anchor" id="ae1683035d05edcc99ecf90344129b7c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OptimalBinning::Initialize </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>algo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the histogram with the optimal binning. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td><img class="formulaInl" alt="$N_1\times...\times N_n$" src="form_15.png"/> vector of points of n dimensions </td></tr>
    <tr><td class="paramname">algo</td><td>Algorithm to be used for binning optimization </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a444434f52f1b4579c5c11a94504151cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; TPolyLine * &gt; OptimalBinning::Meshing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the meshing, used to build the interpolation, as polygons. </p>

</div>
</div>
<a class="anchor" id="a2b77dd36ac6fff9f31a6dd314e1e7a12"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double OptimalBinning::operator() </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloaded function operator, calls Evaluate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td><a class="el" href="classVector.html" title="Object that can host any type of data in a vector arrangement. ">Vector</a> of coordinates </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9ed29b458a64a6f9897b357b4f125bcd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double OptimalBinning::operator() </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloaded function operator, calls Evaluate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>One dimensional value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aab71e6a54281a0be74b2c3ce641a4137"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double OptimalBinning::operator() </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloaded function operator, calls Evaluate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Pointer to an array of coordinates </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a09f1b07d9c98fcfab99888e88b8e3cd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOptimalBinning.html">OptimalBinning</a> &amp; OptimalBinning::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOptimalBinning.html">OptimalBinning</a> &amp;&#160;</td>
          <td class="paramname"><em>ob</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality operator. </p>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a class="anchor" id="a96b27003537da10a26f1a3205251b4b3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t OptimalBinning::_dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dimension of the space the estimator lives in. </p>

</div>
</div>
<a class="anchor" id="a0ab7873e2cb07e512a012df313924f23"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OptimalBinning::_ex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extrapolate if true. </p>

</div>
</div>
<a class="anchor" id="adc27a1e5fb9764cfc0596640b1827dc9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHistogram.html">Histogram</a> OptimalBinning::_hist</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optimal histogram for density estimation. </p>

</div>
</div>
<a class="anchor" id="a19f7e8874e0939fbcc2bd8310de515c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classInterpolator.html">Interpolator</a> OptimalBinning::_int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classGrid.html" title="Data structure for a grid of points and their mapping onto a scalar field. ">Grid</a> interpolator. </p>

</div>
</div>
<a class="anchor" id="a84bae9eeb8c8ce34b3390ae5bec1e94b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OptimalBinning::_interp</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply grid interpolation if true. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/de/<a class="el" href="OptimalBinning_8hh_source.html">OptimalBinning.hh</a></li>
<li>src/de/OptimalBinning.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Jun 2 2018 23:17:10 for SynAPSE by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
